#include <linux/sched.h>#include <linux/rcupdate.h>#include <linux/module.h>   /* Needed by all modules */#include <linux/kernel.h>   /* Needed for KERN_INFO */#include <linux/proc_fs.h>#include <linux/string.h>#include <linux/vmalloc.h>#include <linux/uaccess.h>#include <linux/init.h>#include <asm/siginfo.h>#include <linux/signal.h>#include <linux/slab.h>#include <linux/fs.h>#include <linux/tty.h>MODULE_LICENSE("GPL");#define CHR_DEV_NAME "battery" // 디바이스 파일 이름#define CHR_DEV_MAJOR 240 // 디바이스 파일의 주번호#define PROCFS_MAX_SIZE         1024#define PROCFS_TESTLEVEL        "battery_test"#define PROCFS_NOTIFYPID        "battery_notify"#define PROCFS_THRESHOLD        "battery_threshold"/* Declaration of variables used in this module */static char *buffer = NULL;static int level = 99;static int test_level = 0;        //indicates level of battery remain.static int notify_pid = 0;static int threshold = 0;/* End of declaration *//* Declaration of ancillary variables */static char test_buffer[PROCFS_MAX_SIZE], notify_buffer[PROCFS_MAX_SIZE], threshold_buffer[PROCFS_MAX_SIZE];     static unsigned long procfs_buffer_size = 0;    //size of receive side bufferstatic struct proc_dir_entry *test_level_entry, *notify_pid_entry, *threshold_entry;       //indicates procfs entry./* End of declaration */int chr_open(struct inode *inode, struct file *filp){int number = MINOR(inode->i_rdev); // 부번호를 number에 저장printk("Virtual Character Device Open: Minor Number is %d\n", number);return 0;}ssize_t chr_write(struct file *filp, const char *buf, size_t count, loff_t *f_pos){copy_from_user(buffer, buf, count); // 디바이스 파일에 데이터 기록printk("write data: %s\n", buf); // 응용프로그램 write()// 함수의 buf 값을 커널 메시지에 출력return count;}ssize_t chr_read(struct file *filp, const char *buf, size_t count, loff_t *f_pos){copy_to_user(buf, buffer, count); // 디파이스 파일에 있는 데이터 읽기printk("read data: %s\n", buf); // 응용프로그램 read()// 함수의 buf 값을 커널 메시지에 출력return count;}int chr_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg){switch(cmd) { // ioctl 함수로 전달된 cmd 값을 출력case 0: printk("cmd value is %d\n", cmd); break;case 4: printk("cmd value is %d\n", cmd); break;}return 0;}int chr_release(struct inode *inode, struct file *filp){printk("Virtual Character Device Release\n");return 0;}struct file_operations chr_fops ={owner: THIS_MODULE,unlocked_ioctl: chr_ioctl,write: chr_write,read: chr_read,open: chr_open,release: chr_release};static int test_level_write( struct file *filp, const char *user_space_buffer, unsigned long len, loff_t *off ){        int status = 0;        int requested;        procfs_buffer_size = len;        if (procfs_buffer_size > PROCFS_MAX_SIZE ) 		{                procfs_buffer_size = PROCFS_MAX_SIZE;        	}        /* write data to the buffer */	        if ( copy_from_user(test_buffer, user_space_buffer, procfs_buffer_size) ) 		{                return -EFAULT;       		}        status  = kstrtoint(test_buffer, 10, &requested);        if(status < 0)        	{                printk(KERN_INFO "Error while called kstrtoint(...)\n");                return -ENOMEM;        	}        // validate level value.        if(requested< 0 || requested > 100)		{                printk(KERN_INFO "Invalid battery level.\n");                return -ENOMEM;        	}        // accept value.        test_level = requested;        *off += procfs_buffer_size; // not necessary here!        return procfs_buffer_size;}/*        Implementation of procfs read function*/static int test_level_read( struct file *filp, char *user_space_buffer, size_t count, loff_t *off ){        int ret = 0;        int flag = 0;        if(*off < 0) *off = 0;        snprintf(test_buffer, 16, "%d\n", test_level);        procfs_buffer_size = strlen(test_buffer);        if(*off > procfs_buffer_size)		{                return -EFAULT;        	}		else if(*off == procfs_buffer_size)		{                return 0;        	}        if(procfs_buffer_size - *off > count)                ret = count;        else                ret = procfs_buffer_size - *off;        flag = copy_to_user(user_space_buffer, test_buffer + (*off), ret);        if(flag < 0)                return -EFAULT;        *off += ret;        return ret;}static int notify_pid_write( struct file *filp, const char *user_space_buffer, unsigned long len, loff_t *off ){        int status = 0;        int requested;        procfs_buffer_size = len;        if (procfs_buffer_size > PROCFS_MAX_SIZE ) 		{                procfs_buffer_size = PROCFS_MAX_SIZE;        	}        /* write data to the buffer */	        if ( copy_from_user(notify_buffer, user_space_buffer, procfs_buffer_size) ) 		{                return -EFAULT;       		}        status  = kstrtoint(notify_buffer, 10, &requested);        if(status < 0)        	{                printk(KERN_INFO "Error while called kstrtoint(...)\n");                return -ENOMEM;        	}        // validate level value.        if(requested< 0 || requested > 100000)		{                printk(KERN_INFO "Invalid Process ID.\n");                return -ENOMEM;        	}        // accept value.        notify_pid = requested;        *off += procfs_buffer_size; // not necessary here!        return procfs_buffer_size;}/*        Implementation of procfs read function*/static int notify_pid_read( struct file *filp, char *user_space_buffer, size_t count, loff_t *off ){        int ret = 0;        int flag = 0;        if(*off < 0) *off = 0;        snprintf(notify_buffer, 16, "%d\n", notify_pid);        procfs_buffer_size = strlen(notify_buffer);        if(*off > procfs_buffer_size)		{                return -EFAULT;        	}		else if(*off == procfs_buffer_size)		{                return 0;        	}        if(procfs_buffer_size - *off > count)                ret = count;        else                ret = procfs_buffer_size - *off;        flag = copy_to_user(user_space_buffer, notify_buffer + (*off), ret);        if(flag < 0)                return -EFAULT;        *off += ret;        return ret;}static int threshold_write( struct file *filp, const char *user_space_buffer, unsigned long len, loff_t *off ){        int status = 0;        int requested;        procfs_buffer_size = len;        if (procfs_buffer_size > PROCFS_MAX_SIZE ) 		{                procfs_buffer_size = PROCFS_MAX_SIZE;        	}        /* write data to the buffer */	        if ( copy_from_user(threshold_buffer, user_space_buffer, procfs_buffer_size) ) 		{                return -EFAULT;       		}        status  = kstrtoint(threshold_buffer, 10, &requested);        if(status < 0)        	{                printk(KERN_INFO "Error while called kstrtoint(...)\n");                return -ENOMEM;        	}        // validate level value.        if(requested< 0 || requested > 100)		{                printk(KERN_INFO "Invalid threshold.\n");                return -ENOMEM;        	}        // accept value.        threshold = requested;        *off += procfs_buffer_size; // not necessary here!        return procfs_buffer_size;}/*        Implementation of procfs read function*/static int threshold_read( struct file *filp, char *user_space_buffer, size_t count, loff_t *off ){        int ret = 0;        int flag = 0;        if(*off < 0) *off = 0;        snprintf(threshold_buffer, 16, "%d\n", threshold);        procfs_buffer_size = strlen(threshold_buffer);        if(*off > procfs_buffer_size)		{                return -EFAULT;        	}		else if(*off == procfs_buffer_size)		{                return 0;        	}        if(procfs_buffer_size - *off > count)                ret = count;        else                ret = procfs_buffer_size - *off;        flag = copy_to_user(user_space_buffer, threshold_buffer + (*off), ret);        if(flag < 0)                return -EFAULT;        *off += ret;        return ret;}/*        Configuration of file_operations        This structure indicate functions when read or write operation occured.*/static const struct file_operations my_test_level_fops = {        .write = test_level_write,        .read = test_level_read,};static const struct file_operations my_notify_pid_fops = {        .write =notify_pid_write,        .read = notify_pid_read,};static const struct file_operations my_threshold_fops = {        .write = threshold_write,        .read = threshold_read,};/*        This function will be called on initialization of  kernel module*/int init_module(void){        int ret = 0;        test_level_entry = proc_create(PROCFS_TESTLEVEL, 0666, NULL, &my_test_level_fops);		notify_pid_entry = proc_create(PROCFS_NOTIFYPID, 0666, NULL, &my_notify_pid_fops);		threshold_entry = proc_create(PROCFS_THRESHOLD, 0666, NULL, &my_threshold_fops);        if(test_level_entry == NULL || notify_pid_entry == NULL || threshold_entry == NULL)        	{                return -ENOMEM;       	 	}		int registration;; // registration에 주번호나 반환값을 저장		printk("Registration Character Device to Kernel\n");		registration = register_chrdev(CHR_DEV_MAJOR,CHR_DEV_NAME, &chr_fops);		if(registration < 0)			return registration;		printk("Major Number:%d\n", registration);		buffer = (char*)kmalloc(1024, GFP_KERNEL); // buffer 메모리 할당		if(buffer != NULL) // buffer 값이 null일 때 buffer 값 초기화			memset(buffer, 0, 1024);        return ret;}/*        This function will be called on cleaning up of kernel module*/void cleanup_module(void){        remove_proc_entry(PROCFS_TESTLEVEL, test_level_entry);		remove_proc_entry(PROCFS_NOTIFYPID, notify_pid_entry);		remove_proc_entry(PROCFS_THRESHOLD, threshold_entry);		printk("Unregistration Character Device to Kernel\n");		unregister_chrdev(CHR_DEV_MAJOR, CHR_DEV_NAME);		kfree(buffer); // buffer 메모리 해제}//EXPORT_SYMBOL(notify);